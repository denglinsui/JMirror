% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/JointMirrorR.R
\name{JointMirror.R}
\alias{JointMirror.R}
\title{Title
Joint Mirror Procedure}
\usage{
JointMirror.R(
  Pval,
  init.thred = 0.2,
  offset = 1,
  trgt.fdr.level = 0.1,
  rank.Mode = "Product",
  Ker.base = "InProjPval",
  Ker.BW = "Silverman",
  is.gc = T
)
}
\arguments{
\item{Pval}{a m*K matrix for p-values;}

\item{init.thred}{a value between 0 to 0.5 to determine the initial state;}

\item{offset}{a positive value at the enumerator of FDP estimator to guarantee finite sample FDR control;}

\item{trgt.fdr.level}{a value between 0 to 1 representing the target fdr level;}

\item{rank.Mode}{a character representing the selected partial order, including "Product","Max"/"Pmax","NoShape"/"EmptyPoset".}

\item{Ker.base}{a character indicating which part of the data to use to adjust the bandwidth, including "Pval","ProjPval","InProjPval","InPval".}

\item{Ker.BW}{the method for tuning bandwidth, including "Silverman", "Scott" and "Hpi".}

\item{is.gc}{a bool indicating whether we should free some spaces.}
}
\value{
list
selected is the indexes of the selected hypotheses.
Hker.inv.chol is the bandwidth matrix for kerne density estimation.
JMirrorS is a module storing the results of joint mirror procedure.
}
\description{
A multiple testing procedure for testing simultaneous signals.
}
\examples{
set.seed(10)
m <- 1000
mu1H10 <- 1.5
mu1H11 <- 2
mu2H01 <- 2.5
mu2H11 <- 3
pi.seq <- c(0.4,0.2,0.2,0.2)
H <- rmultinom(m,1,pi.seq)
H0 <- colSums(H[1:3,])
mu1 <- mu2 <- rep(0,m)

mu1[H[2,]==1] <- mu1H10
mu1[H[4,]==1] <- mu1H11
mu2[H[3,]==1] <- mu2H01
mu2[H[4,]==1] <- mu2H11

X1 <- rnorm(m,mu1)
X2 <- rnorm(m,mu2)

p1 <- 2*(pnorm(-abs(X1)))
p2 <- 2*(pnorm(-abs(X2)))

trgt.fdr.level <- 0.2
Pval <- cbind(p1,p2)
JM.Product.Res <- JointMirror.R(Pval = cbind(p1,p2),rank.Mode = "Product",
                                trgt.fdr.level=trgt.fdr.level)
JM.Max.Res <- JointMirror.R(Pval = cbind(p1,p2),rank.Mode = "Max",
                            trgt.fdr.level=trgt.fdr.level)
JM.EmptyPoset.Res <- JointMirror.R(Pval = cbind(p1,p2),rank.Mode = "EmptyPoset",
                                   trgt.fdr.level=trgt.fdr.level)

c(fdp(JM.Product.Res$selected,H0),fdp(JM.Max.Res$selected,H0),fdp(JM.EmptyPoset.Res$selected,H0))
c(Pow(JM.Product.Res$selected,H0),Pow(JM.Max.Res$selected,H0),Pow(JM.EmptyPoset.Res$selected,H0))
}
